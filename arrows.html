<canvas id="gc" width="400" height="400"></canvas>
<script>
    window.onload = function () {
        canv = document.getElementById("gc");
        ctx = canv.getContext("2d");

        document.addEventListener("keydown", keyDown);
        document.addEventListener("keyup", keyUp);

        requestAnimationFrame(mainLoop);
    }

    lastFrameTimeMs = 0;
    delta = 0;
    timestep = 1000 / 60;
    maxFPS = 60;

    player = {
        x: 0,
        y: 0,
        xv: 0,
        yv: 0,
        last_xv: 1,
        last_yv: 0,
        updatePosition: function (delta) {
            this.x += this.xv * delta / 10;
            this.y += this.yv * delta / 10;
            if (this.x < 0) {
                this.x = tileCount - 1;
            }
            if (this.y < 0) {
                this.y = tileCount - 1;
            }
            if (this.x >= tileCount) {
                this.x = 0;
            }
            if (this.y >= tileCount) {
                this.y = 0;
            }
        },
        setXDirection: function (xv) {
            player.xv = xv;
            this.last_xv = this.xv;
            this.last_yv = 0;
        },
        setYDirection: function (yv) {
            player.yv = yv;
            this.last_xv = 0;
            this.last_yv = this.yv;
        },
        stopX: function () {
            player.xv = 0;
        },
        stopY: function () {
            player.yv = 0;
        }
    };

    enemy = {
        x: 10,
        y: 10
    };

    arrows = [];

    tileCount = 20;
    tileSize = 20;

    function update(delta) {
        player.updatePosition(delta);

        for (var i = 0; i < arrows.length; i++) {
            arrows[i].updatePosition(delta);
        }

        if (collide(player, enemy)) {
            enemy.x = Math.floor(Math.random() * tileCount);
            enemy.y = Math.floor(Math.random() * tileCount);
        }
    }

    function collide(a, b) {
        return a.x == b.x && a.y == b.y;
    }

    function draw() {
        ctx.fillStyle = "black";
        ctx.fillRect(0, 0, canv.width, canv.height);

        // ctx.fillStyle = "white";
        // ctx.font = "30px Arial";
        // ctx.fillText(player.last_xv, 20, 50);
        // ctx.fillText(player.last_yv, 20, 80);

        drawTile(player.x, player.y, "lime");
        drawTile(enemy.x, enemy.y, "red");

        for (var i = 0; i < arrows.length; i++) {
            drawTile(arrows[i].x, arrows[i].y, "yellow");
        }
    }

    function panic() {
        delta = 0;
    }

    function drawTile(row, col, color) {
        ctx.fillStyle = color;
        ctx.fillRect(row * tileSize, col * tileSize, tileSize, tileSize);
    }

    function createArrow(row, col, xv, yv) {
        var arrow = {
            x: row,
            y: col,
            xv: xv,
            yv: yv,
            updatePosition: function (delta) {
                this.x += this.xv * delta / 10;
                this.y += this.yv * delta / 10;
                if (this.x < 0) {
                    this.x = tileCount - 1;
                }
                if (this.y < 0) {
                    this.y = tileCount - 1;
                }
                if (this.x >= tileCount) {
                    this.x = 0;
                }
                if (this.y >= tileCount) {
                    this.y = 0;
                }
            }
        };

        return arrow;
    }

    function keyDown(event) {
        switch (event.code) {
            case "ArrowLeft":
                player.setXDirection(-0.1);
                break;
            case "ArrowUp":
                player.setYDirection(-0.1);
                break;
            case "ArrowRight":
                player.setXDirection(0.1);
                break;
            case "ArrowDown":
                player.setYDirection(0.1);
                break;
            case "Space":
                var arrow = createArrow(player.x, player.y, player.last_xv*3, player.last_yv*3);
                arrows.push(arrow);
                break;
        }
    }

    function keyUp(event) {
        switch (event.code) {
            case "ArrowLeft":
                player.stopX();
                break;
            case "ArrowUp":
                player.stopY();
                break;
            case "ArrowRight":
                player.stopX();
                break;
            case "ArrowDown":
                player.stopY();
                break;
        }
    }

    function mainLoop(timestamp) {
        // Throttle the frame rate.
        if (timestamp < lastFrameTimeMs + (1000 / maxFPS)) {
            requestAnimationFrame(mainLoop);
            return;
        }

        // Track the accumulated time that hasn't been simulated yet
        delta += timestamp - lastFrameTimeMs; // note += here
        lastFrameTimeMs = timestamp;

        // Simulate the total elapsed time in fixed-size chunks
        var numUpdateSteps = 0;
        while (delta >= timestep) {
            update(timestep);
            delta -= timestep;
            if (++numUpdateSteps >= 240) {
                panic();
                break;
            }
        }
        draw();
        requestAnimationFrame(mainLoop);
    }
</script>